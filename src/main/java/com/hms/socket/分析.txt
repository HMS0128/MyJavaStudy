【概述】
目标：实现一个简易的多人聊天室。

基本要素：一个服务器、N个客户端

每个客户端需要有一个唯一标识，每个客户端的端口号是唯一的，例如：张三（192.168.110.1:10001）。

【socket读写】
注意：
一个socket连接的两端，各有输入输出流，共计四个流，用完都需关闭，一方读的时候会等对方写入数据。
当一方写入完成后，调用shutdownOutput关闭输出流，这时候对方的read方法就会返回-1，这时候对方就知道你写完了，对方可以关闭输入流，
然后等待对方写入完成调用shutdownOutput后己方再调用shutdownInput，双方就正常关闭了输入输出流，这时候socket就不会出现异常了。

问题：
1、Socket阻塞情景
    ServerSocket 的accept() 方法, 假如没有客户连接, 该线程就会一直等到有客户连接才从 accept() 方法返回。
    Socket 读取数据时, 如果输入流中没有数据, 该线程就会一直等到读到数据才返回。

2、一个socket连接实现无限读写
    一方读的时候会等对方写入数据，当socket写入的流关闭时读取数据是null或-1，
    所以读数据时用一个循环就可以了，如果无数据会阻塞等待，条件设置为有数据就读取一行不等于null或读取单个字符不等于-1
    写的时候也用一个循环无限写，可以用键盘录入的方式 控制写入的时间。
    然后不关闭流。

【实现思路】
多个客户端对应一个服务器，客户端不需要线程，服务端需要多个线程，一个线程对应一个客户端。
当一个服务端线程读取到数据，其他服务端线程应同步写入读取到的线程。
    实现思路：volatile 修饰的变量只要被修改，所有线程读取到的一定是最新值，所以服务端读情景的数据保存在这个变量上，写入客户端时，服务端所有线程不允许读。


【读写情景】
客户端读情景：只要服务端写入数据就读。
客户端写情景：读取键盘录入的方式控制写的时间，或按钮触发来控制写的时间。

服务端读情景：只要客户端写入数据就读。

服务端写情景：当服务端读到数据，所有服务端线程都得写这个数据，所有线程写完在都开始读。
        -- 1、怎么实现全部线程都去写这个数据？

服务端（所有服务端线程都写）：
boolean flag = true;
while ((共享变量!=null || (str=读出数据) != null) && flag)
{
    if(str!=null){
        共享变量 = str;
    }
    写数据;
    flag = false;
    暂停等待所有线程写完继续运行（定义一个flag标记 ）
    str = null;
}
        -- 2、怎么是写暂停等待所有线程写完继续运行？





